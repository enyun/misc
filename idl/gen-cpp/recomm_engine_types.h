/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef recomm_engine_TYPES_H
#define recomm_engine_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "fb303_types.h"


namespace recomm_engine { namespace idl {

enum RecommendationResponseCode {
  RRC_OK = 0,
  RRC_ERROR = 1,
  RRC_UID_NOT_FOUND = 2,
  RRC_NO_DOC = 3,
  RRC_NO_CANDIDATE = 4,
  RRC_NO_PROFILE = 5,
  RRC_EMPTY_RANK_RESULT = 6
};

extern const std::map<int, const char*> _RecommendationResponseCode_VALUES_TO_NAMES;

enum StoryManagementStatus {
  SMS_OK = 0,
  SMS_ERROR = 1
};

extern const std::map<int, const char*> _StoryManagementStatus_VALUES_TO_NAMES;

enum UserEngagementType {
  UET_CLICK = 0,
  UET_FAVORITE = 2,
  UET_SHARE = 3,
  UET_LIKE = 4
};

extern const std::map<int, const char*> _UserEngagementType_VALUES_TO_NAMES;

enum RetrievalResponseCode {
  STATE_OK = 0,
  STATE_ERROR = 1,
  STATE_KEYWORD_NOT_FOUND = 2
};

extern const std::map<int, const char*> _RetrievalResponseCode_VALUES_TO_NAMES;


class RecommendationRequest {
 public:

  static const char* ascii_fingerprint; // = "52F7D5E8217C4B8FC14F1F30BF2EB41C";
  static const uint8_t binary_fingerprint[16]; // = {0x52,0xF7,0xD5,0xE8,0x21,0x7C,0x4B,0x8F,0xC1,0x4F,0x1F,0x30,0xBF,0x2E,0xB4,0x1C};

  RecommendationRequest() : uid(), ip(), topN(0) {
  }

  virtual ~RecommendationRequest() throw() {}

  std::string uid;
  std::string ip;
  int16_t topN;

  void __set_uid(const std::string& val) {
    uid = val;
  }

  void __set_ip(const std::string& val) {
    ip = val;
  }

  void __set_topN(const int16_t val) {
    topN = val;
  }

  bool operator == (const RecommendationRequest & rhs) const
  {
    if (!(uid == rhs.uid))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(topN == rhs.topN))
      return false;
    return true;
  }
  bool operator != (const RecommendationRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecommendationRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RecommendationRequest &a, RecommendationRequest &b);

typedef struct _RecommendationResult__isset {
  _RecommendationResult__isset() : debug_info(false) {}
  bool debug_info;
} _RecommendationResult__isset;

class RecommendationResult {
 public:

  static const char* ascii_fingerprint; // = "CAD99879040BB94BCA63533B6094F391";
  static const uint8_t binary_fingerprint[16]; // = {0xCA,0xD9,0x98,0x79,0x04,0x0B,0xB9,0x4B,0xCA,0x63,0x53,0x3B,0x60,0x94,0xF3,0x91};

  RecommendationResult() : story_id(), score(100), debug_info() {
  }

  virtual ~RecommendationResult() throw() {}

  std::string story_id;
  double score;
  std::string debug_info;

  _RecommendationResult__isset __isset;

  void __set_story_id(const std::string& val) {
    story_id = val;
  }

  void __set_score(const double val) {
    score = val;
  }

  void __set_debug_info(const std::string& val) {
    debug_info = val;
    __isset.debug_info = true;
  }

  bool operator == (const RecommendationResult & rhs) const
  {
    if (!(story_id == rhs.story_id))
      return false;
    if (!(score == rhs.score))
      return false;
    if (__isset.debug_info != rhs.__isset.debug_info)
      return false;
    else if (__isset.debug_info && !(debug_info == rhs.debug_info))
      return false;
    return true;
  }
  bool operator != (const RecommendationResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecommendationResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RecommendationResult &a, RecommendationResult &b);


class RecommendationResponse {
 public:

  static const char* ascii_fingerprint; // = "C04876C50242DAF31640D50DF90A7579";
  static const uint8_t binary_fingerprint[16]; // = {0xC0,0x48,0x76,0xC5,0x02,0x42,0xDA,0xF3,0x16,0x40,0xD5,0x0D,0xF9,0x0A,0x75,0x79};

  RecommendationResponse() : response_code((RecommendationResponseCode)0) {
    response_code = (RecommendationResponseCode)0;

  }

  virtual ~RecommendationResponse() throw() {}

  RecommendationResponseCode response_code;
  std::vector<RecommendationResult>  results;

  void __set_response_code(const RecommendationResponseCode val) {
    response_code = val;
  }

  void __set_results(const std::vector<RecommendationResult> & val) {
    results = val;
  }

  bool operator == (const RecommendationResponse & rhs) const
  {
    if (!(response_code == rhs.response_code))
      return false;
    if (!(results == rhs.results))
      return false;
    return true;
  }
  bool operator != (const RecommendationResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecommendationResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RecommendationResponse &a, RecommendationResponse &b);

typedef struct _StoryProfile__isset {
  _StoryProfile__isset() : topics(false) {}
  bool topics;
} _StoryProfile__isset;

class StoryProfile {
 public:

  static const char* ascii_fingerprint; // = "67C4FE21DB0D8EF31ABA6CC39AFAA67D";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0xC4,0xFE,0x21,0xDB,0x0D,0x8E,0xF3,0x1A,0xBA,0x6C,0xC3,0x9A,0xFA,0xA6,0x7D};

  StoryProfile() : story_id(), signature(0) {
  }

  virtual ~StoryProfile() throw() {}

  std::string story_id;
  std::map<int64_t, int32_t>  keywords;
  std::vector<int32_t>  topics;
  int64_t signature;

  _StoryProfile__isset __isset;

  void __set_story_id(const std::string& val) {
    story_id = val;
  }

  void __set_keywords(const std::map<int64_t, int32_t> & val) {
    keywords = val;
  }

  void __set_topics(const std::vector<int32_t> & val) {
    topics = val;
    __isset.topics = true;
  }

  void __set_signature(const int64_t val) {
    signature = val;
  }

  bool operator == (const StoryProfile & rhs) const
  {
    if (!(story_id == rhs.story_id))
      return false;
    if (!(keywords == rhs.keywords))
      return false;
    if (__isset.topics != rhs.__isset.topics)
      return false;
    else if (__isset.topics && !(topics == rhs.topics))
      return false;
    if (!(signature == rhs.signature))
      return false;
    return true;
  }
  bool operator != (const StoryProfile &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StoryProfile & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StoryProfile &a, StoryProfile &b);


class StoryAddingRequest {
 public:

  static const char* ascii_fingerprint; // = "15D50B2E6CD7D07EA922D3FEE80981CE";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0xD5,0x0B,0x2E,0x6C,0xD7,0xD0,0x7E,0xA9,0x22,0xD3,0xFE,0xE8,0x09,0x81,0xCE};

  StoryAddingRequest() {
  }

  virtual ~StoryAddingRequest() throw() {}

  StoryProfile story;

  void __set_story(const StoryProfile& val) {
    story = val;
  }

  bool operator == (const StoryAddingRequest & rhs) const
  {
    if (!(story == rhs.story))
      return false;
    return true;
  }
  bool operator != (const StoryAddingRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StoryAddingRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StoryAddingRequest &a, StoryAddingRequest &b);


class StoryAddingResponse {
 public:

  static const char* ascii_fingerprint; // = "8BBB3D0C3B370CB38F2D1340BB79F0AA";
  static const uint8_t binary_fingerprint[16]; // = {0x8B,0xBB,0x3D,0x0C,0x3B,0x37,0x0C,0xB3,0x8F,0x2D,0x13,0x40,0xBB,0x79,0xF0,0xAA};

  StoryAddingResponse() : status((StoryManagementStatus)0) {
    status = (StoryManagementStatus)0;

  }

  virtual ~StoryAddingResponse() throw() {}

  StoryManagementStatus status;

  void __set_status(const StoryManagementStatus val) {
    status = val;
  }

  bool operator == (const StoryAddingResponse & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const StoryAddingResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StoryAddingResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StoryAddingResponse &a, StoryAddingResponse &b);

typedef struct _UserProfile__isset {
  _UserProfile__isset() : topics(false) {}
  bool topics;
} _UserProfile__isset;

class UserProfile {
 public:

  static const char* ascii_fingerprint; // = "2E9E4E74D2659458ADE8CE440105F612";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x9E,0x4E,0x74,0xD2,0x65,0x94,0x58,0xAD,0xE8,0xCE,0x44,0x01,0x05,0xF6,0x12};

  UserProfile() : uid() {
  }

  virtual ~UserProfile() throw() {}

  std::string uid;
  std::map<int64_t, int32_t>  keywords;
  std::vector<int32_t>  topics;
  std::vector<int64_t>  history;

  _UserProfile__isset __isset;

  void __set_uid(const std::string& val) {
    uid = val;
  }

  void __set_keywords(const std::map<int64_t, int32_t> & val) {
    keywords = val;
  }

  void __set_topics(const std::vector<int32_t> & val) {
    topics = val;
    __isset.topics = true;
  }

  void __set_history(const std::vector<int64_t> & val) {
    history = val;
  }

  bool operator == (const UserProfile & rhs) const
  {
    if (!(uid == rhs.uid))
      return false;
    if (!(keywords == rhs.keywords))
      return false;
    if (__isset.topics != rhs.__isset.topics)
      return false;
    else if (__isset.topics && !(topics == rhs.topics))
      return false;
    if (!(history == rhs.history))
      return false;
    return true;
  }
  bool operator != (const UserProfile &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserProfile & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UserProfile &a, UserProfile &b);

typedef struct _UserHistoryItem__isset {
  _UserHistoryItem__isset() : type(true), timestamp(true) {}
  bool type;
  bool timestamp;
} _UserHistoryItem__isset;

class UserHistoryItem {
 public:

  static const char* ascii_fingerprint; // = "D4463D0DA0421E5B34FED5691C125569";
  static const uint8_t binary_fingerprint[16]; // = {0xD4,0x46,0x3D,0x0D,0xA0,0x42,0x1E,0x5B,0x34,0xFE,0xD5,0x69,0x1C,0x12,0x55,0x69};

  UserHistoryItem() : story_id(), type((UserEngagementType)0), timestamp(0LL) {
    type = (UserEngagementType)0;

  }

  virtual ~UserHistoryItem() throw() {}

  std::string story_id;
  UserEngagementType type;
  int64_t timestamp;

  _UserHistoryItem__isset __isset;

  void __set_story_id(const std::string& val) {
    story_id = val;
  }

  void __set_type(const UserEngagementType val) {
    type = val;
    __isset.type = true;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
    __isset.timestamp = true;
  }

  bool operator == (const UserHistoryItem & rhs) const
  {
    if (!(story_id == rhs.story_id))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.timestamp != rhs.__isset.timestamp)
      return false;
    else if (__isset.timestamp && !(timestamp == rhs.timestamp))
      return false;
    return true;
  }
  bool operator != (const UserHistoryItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserHistoryItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UserHistoryItem &a, UserHistoryItem &b);

typedef struct _UserHistory__isset {
  _UserHistory__isset() : history_items(false) {}
  bool history_items;
} _UserHistory__isset;

class UserHistory {
 public:

  static const char* ascii_fingerprint; // = "C785912897479087A2B9E0BAC2804639";
  static const uint8_t binary_fingerprint[16]; // = {0xC7,0x85,0x91,0x28,0x97,0x47,0x90,0x87,0xA2,0xB9,0xE0,0xBA,0xC2,0x80,0x46,0x39};

  UserHistory() {
  }

  virtual ~UserHistory() throw() {}

  std::vector<UserHistoryItem>  history_items;

  _UserHistory__isset __isset;

  void __set_history_items(const std::vector<UserHistoryItem> & val) {
    history_items = val;
  }

  bool operator == (const UserHistory & rhs) const
  {
    if (!(history_items == rhs.history_items))
      return false;
    return true;
  }
  bool operator != (const UserHistory &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserHistory & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UserHistory &a, UserHistory &b);


class IndexingAttachment {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  IndexingAttachment() : global_docid(0) {
  }

  virtual ~IndexingAttachment() throw() {}

  int64_t global_docid;

  void __set_global_docid(const int64_t val) {
    global_docid = val;
  }

  bool operator == (const IndexingAttachment & rhs) const
  {
    if (!(global_docid == rhs.global_docid))
      return false;
    return true;
  }
  bool operator != (const IndexingAttachment &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IndexingAttachment & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(IndexingAttachment &a, IndexingAttachment &b);

typedef struct _RetrievalRequestInfo__isset {
  _RetrievalRequestInfo__isset() : weight(true) {}
  bool weight;
} _RetrievalRequestInfo__isset;

class RetrievalRequestInfo {
 public:

  static const char* ascii_fingerprint; // = "6E578DA8AB10EED824A75534350EBAEF";
  static const uint8_t binary_fingerprint[16]; // = {0x6E,0x57,0x8D,0xA8,0xAB,0x10,0xEE,0xD8,0x24,0xA7,0x55,0x34,0x35,0x0E,0xBA,0xEF};

  RetrievalRequestInfo() : keyword(0), weight(0) {
  }

  virtual ~RetrievalRequestInfo() throw() {}

  int64_t keyword;
  int32_t weight;

  _RetrievalRequestInfo__isset __isset;

  void __set_keyword(const int64_t val) {
    keyword = val;
  }

  void __set_weight(const int32_t val) {
    weight = val;
    __isset.weight = true;
  }

  bool operator == (const RetrievalRequestInfo & rhs) const
  {
    if (!(keyword == rhs.keyword))
      return false;
    if (__isset.weight != rhs.__isset.weight)
      return false;
    else if (__isset.weight && !(weight == rhs.weight))
      return false;
    return true;
  }
  bool operator != (const RetrievalRequestInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RetrievalRequestInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RetrievalRequestInfo &a, RetrievalRequestInfo &b);

typedef struct _RetrievalRequest__isset {
  _RetrievalRequest__isset() : debug_level(true), log_level(true) {}
  bool debug_level;
  bool log_level;
} _RetrievalRequest__isset;

class RetrievalRequest {
 public:

  static const char* ascii_fingerprint; // = "2E6066C9C3F41870FD30C6EE831CB99D";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x60,0x66,0xC9,0xC3,0xF4,0x18,0x70,0xFD,0x30,0xC6,0xEE,0x83,0x1C,0xB9,0x9D};

  RetrievalRequest() : debug_level(0), log_level(0) {
  }

  virtual ~RetrievalRequest() throw() {}

  std::vector<RetrievalRequestInfo>  keywords;
  int16_t debug_level;
  int16_t log_level;

  _RetrievalRequest__isset __isset;

  void __set_keywords(const std::vector<RetrievalRequestInfo> & val) {
    keywords = val;
  }

  void __set_debug_level(const int16_t val) {
    debug_level = val;
    __isset.debug_level = true;
  }

  void __set_log_level(const int16_t val) {
    log_level = val;
    __isset.log_level = true;
  }

  bool operator == (const RetrievalRequest & rhs) const
  {
    if (!(keywords == rhs.keywords))
      return false;
    if (__isset.debug_level != rhs.__isset.debug_level)
      return false;
    else if (__isset.debug_level && !(debug_level == rhs.debug_level))
      return false;
    if (__isset.log_level != rhs.__isset.log_level)
      return false;
    else if (__isset.log_level && !(log_level == rhs.log_level))
      return false;
    return true;
  }
  bool operator != (const RetrievalRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RetrievalRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RetrievalRequest &a, RetrievalRequest &b);

typedef struct _RetrievalResult__isset {
  _RetrievalResult__isset() : score(true) {}
  bool score;
} _RetrievalResult__isset;

class RetrievalResult {
 public:

  static const char* ascii_fingerprint; // = "316DE5F40697D7307385A4B83F574754";
  static const uint8_t binary_fingerprint[16]; // = {0x31,0x6D,0xE5,0xF4,0x06,0x97,0xD7,0x30,0x73,0x85,0xA4,0xB8,0x3F,0x57,0x47,0x54};

  RetrievalResult() : story_id(0), score(0) {
  }

  virtual ~RetrievalResult() throw() {}

  int64_t story_id;
  double score;

  _RetrievalResult__isset __isset;

  void __set_story_id(const int64_t val) {
    story_id = val;
  }

  void __set_score(const double val) {
    score = val;
    __isset.score = true;
  }

  bool operator == (const RetrievalResult & rhs) const
  {
    if (!(story_id == rhs.story_id))
      return false;
    if (__isset.score != rhs.__isset.score)
      return false;
    else if (__isset.score && !(score == rhs.score))
      return false;
    return true;
  }
  bool operator != (const RetrievalResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RetrievalResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RetrievalResult &a, RetrievalResult &b);

typedef struct _RetrievalResponse__isset {
  _RetrievalResponse__isset() : num_results(true), results(false) {}
  bool num_results;
  bool results;
} _RetrievalResponse__isset;

class RetrievalResponse {
 public:

  static const char* ascii_fingerprint; // = "191E7FE174C9CE1B28DCD164EAE803E3";
  static const uint8_t binary_fingerprint[16]; // = {0x19,0x1E,0x7F,0xE1,0x74,0xC9,0xCE,0x1B,0x28,0xDC,0xD1,0x64,0xEA,0xE8,0x03,0xE3};

  RetrievalResponse() : resp_code((RetrievalResponseCode)0), num_results(0) {
    resp_code = (RetrievalResponseCode)0;

  }

  virtual ~RetrievalResponse() throw() {}

  RetrievalResponseCode resp_code;
  int32_t num_results;
  std::vector<RetrievalResult>  results;

  _RetrievalResponse__isset __isset;

  void __set_resp_code(const RetrievalResponseCode val) {
    resp_code = val;
  }

  void __set_num_results(const int32_t val) {
    num_results = val;
    __isset.num_results = true;
  }

  void __set_results(const std::vector<RetrievalResult> & val) {
    results = val;
    __isset.results = true;
  }

  bool operator == (const RetrievalResponse & rhs) const
  {
    if (!(resp_code == rhs.resp_code))
      return false;
    if (__isset.num_results != rhs.__isset.num_results)
      return false;
    else if (__isset.num_results && !(num_results == rhs.num_results))
      return false;
    if (__isset.results != rhs.__isset.results)
      return false;
    else if (__isset.results && !(results == rhs.results))
      return false;
    return true;
  }
  bool operator != (const RetrievalResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RetrievalResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RetrievalResponse &a, RetrievalResponse &b);

}} // namespace

#endif
