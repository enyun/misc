#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Recomm::RecommendationResponseCode;
use constant RRC_OK => 0;
use constant RRC_ERROR => 1;
use constant RRC_UID_NOT_FOUND => 2;
use constant RRC_NO_DOC => 3;
use constant RRC_NO_CANDIDATE => 4;
use constant RRC_NO_PROFILE => 5;
use constant RRC_EMPTY_RANK_RESULT => 6;
package Recomm::StoryManagementStatus;
use constant SMS_OK => 0;
use constant SMS_ERROR => 1;
package Recomm::UserEngagementType;
use constant UET_CLICK => 0;
use constant UET_FAVORITE => 2;
use constant UET_SHARE => 3;
use constant UET_LIKE => 4;
package Recomm::RetrievalResponseCode;
use constant STATE_OK => 0;
use constant STATE_ERROR => 1;
use constant STATE_KEYWORD_NOT_FOUND => 2;
package Recomm::RecommendationRequest;
use base qw(Class::Accessor);
Recomm::RecommendationRequest->mk_accessors( qw( uid ip topN ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{uid} = undef;
  $self->{ip} = undef;
  $self->{topN} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{uid}) {
      $self->{uid} = $vals->{uid};
    }
    if (defined $vals->{ip}) {
      $self->{ip} = $vals->{ip};
    }
    if (defined $vals->{topN}) {
      $self->{topN} = $vals->{topN};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommendationRequest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ip});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{topN});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommendationRequest');
  if (defined $self->{uid}) {
    $xfer += $output->writeFieldBegin('uid', TType::STRING, 1);
    $xfer += $output->writeString($self->{uid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ip}) {
    $xfer += $output->writeFieldBegin('ip', TType::STRING, 2);
    $xfer += $output->writeString($self->{ip});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{topN}) {
    $xfer += $output->writeFieldBegin('topN', TType::I16, 3);
    $xfer += $output->writeI16($self->{topN});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::RecommendationResult;
use base qw(Class::Accessor);
Recomm::RecommendationResult->mk_accessors( qw( story_id score debug_info ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{story_id} = undef;
  $self->{score} = 100;
  $self->{debug_info} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{story_id}) {
      $self->{story_id} = $vals->{story_id};
    }
    if (defined $vals->{score}) {
      $self->{score} = $vals->{score};
    }
    if (defined $vals->{debug_info}) {
      $self->{debug_info} = $vals->{debug_info};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommendationResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{story_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{score});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{debug_info});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommendationResult');
  if (defined $self->{story_id}) {
    $xfer += $output->writeFieldBegin('story_id', TType::STRING, 1);
    $xfer += $output->writeString($self->{story_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{score}) {
    $xfer += $output->writeFieldBegin('score', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{score});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{debug_info}) {
    $xfer += $output->writeFieldBegin('debug_info', TType::STRING, 3);
    $xfer += $output->writeString($self->{debug_info});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::RecommendationResponse;
use base qw(Class::Accessor);
Recomm::RecommendationResponse->mk_accessors( qw( response_code results ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{response_code} = 0;
  $self->{results} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{response_code}) {
      $self->{response_code} = $vals->{response_code};
    }
    if (defined $vals->{results}) {
      $self->{results} = $vals->{results};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecommendationResponse';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{response_code});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{results} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Recomm::RecommendationResult();
            $xfer += $elem5->read($input);
            push(@{$self->{results}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecommendationResponse');
  if (defined $self->{response_code}) {
    $xfer += $output->writeFieldBegin('response_code', TType::I32, 1);
    $xfer += $output->writeI32($self->{response_code});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{results}) {
    $xfer += $output->writeFieldBegin('results', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{results}}));
      {
        foreach my $iter6 (@{$self->{results}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::StoryProfile;
use base qw(Class::Accessor);
Recomm::StoryProfile->mk_accessors( qw( story_id keywords topics signature ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{story_id} = undef;
  $self->{keywords} = undef;
  $self->{topics} = undef;
  $self->{signature} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{story_id}) {
      $self->{story_id} = $vals->{story_id};
    }
    if (defined $vals->{keywords}) {
      $self->{keywords} = $vals->{keywords};
    }
    if (defined $vals->{topics}) {
      $self->{topics} = $vals->{topics};
    }
    if (defined $vals->{signature}) {
      $self->{signature} = $vals->{signature};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StoryProfile';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{story_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size7 = 0;
          $self->{keywords} = {};
          my $_ktype8 = 0;
          my $_vtype9 = 0;
          $xfer += $input->readMapBegin(\$_ktype8, \$_vtype9, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $key12 = 0;
            my $val13 = 0;
            $xfer += $input->readI64(\$key12);
            $xfer += $input->readI32(\$val13);
            $self->{keywords}->{$key12} = $val13;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{topics} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $xfer += $input->readI32(\$elem19);
            push(@{$self->{topics}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{signature});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StoryProfile');
  if (defined $self->{story_id}) {
    $xfer += $output->writeFieldBegin('story_id', TType::STRING, 1);
    $xfer += $output->writeString($self->{story_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keywords}) {
    $xfer += $output->writeFieldBegin('keywords', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::I64, TType::I32, scalar(keys %{$self->{keywords}}));
      {
        while( my ($kiter20,$viter21) = each %{$self->{keywords}}) 
        {
          $xfer += $output->writeI64($kiter20);
          $xfer += $output->writeI32($viter21);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{topics}) {
    $xfer += $output->writeFieldBegin('topics', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::I32, scalar(@{$self->{topics}}));
      {
        foreach my $iter22 (@{$self->{topics}}) 
        {
          $xfer += $output->writeI32($iter22);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{signature}) {
    $xfer += $output->writeFieldBegin('signature', TType::I64, 4);
    $xfer += $output->writeI64($self->{signature});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::StoryAddingRequest;
use base qw(Class::Accessor);
Recomm::StoryAddingRequest->mk_accessors( qw( story ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{story} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{story}) {
      $self->{story} = $vals->{story};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StoryAddingRequest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{story} = new Recomm::StoryProfile();
        $xfer += $self->{story}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StoryAddingRequest');
  if (defined $self->{story}) {
    $xfer += $output->writeFieldBegin('story', TType::STRUCT, 1);
    $xfer += $self->{story}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::StoryAddingResponse;
use base qw(Class::Accessor);
Recomm::StoryAddingResponse->mk_accessors( qw( status ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{status} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StoryAddingResponse';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{status});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StoryAddingResponse');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::I32, 1);
    $xfer += $output->writeI32($self->{status});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::UserProfile;
use base qw(Class::Accessor);
Recomm::UserProfile->mk_accessors( qw( uid keywords topics history ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{uid} = undef;
  $self->{keywords} = undef;
  $self->{topics} = undef;
  $self->{history} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{uid}) {
      $self->{uid} = $vals->{uid};
    }
    if (defined $vals->{keywords}) {
      $self->{keywords} = $vals->{keywords};
    }
    if (defined $vals->{topics}) {
      $self->{topics} = $vals->{topics};
    }
    if (defined $vals->{history}) {
      $self->{history} = $vals->{history};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserProfile';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size23 = 0;
          $self->{keywords} = {};
          my $_ktype24 = 0;
          my $_vtype25 = 0;
          $xfer += $input->readMapBegin(\$_ktype24, \$_vtype25, \$_size23);
          for (my $_i27 = 0; $_i27 < $_size23; ++$_i27)
          {
            my $key28 = 0;
            my $val29 = 0;
            $xfer += $input->readI64(\$key28);
            $xfer += $input->readI32(\$val29);
            $self->{keywords}->{$key28} = $val29;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size30 = 0;
          $self->{topics} = [];
          my $_etype33 = 0;
          $xfer += $input->readListBegin(\$_etype33, \$_size30);
          for (my $_i34 = 0; $_i34 < $_size30; ++$_i34)
          {
            my $elem35 = undef;
            $xfer += $input->readI32(\$elem35);
            push(@{$self->{topics}},$elem35);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size36 = 0;
          $self->{history} = [];
          my $_etype39 = 0;
          $xfer += $input->readListBegin(\$_etype39, \$_size36);
          for (my $_i40 = 0; $_i40 < $_size36; ++$_i40)
          {
            my $elem41 = undef;
            $xfer += $input->readI64(\$elem41);
            push(@{$self->{history}},$elem41);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserProfile');
  if (defined $self->{uid}) {
    $xfer += $output->writeFieldBegin('uid', TType::STRING, 1);
    $xfer += $output->writeString($self->{uid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keywords}) {
    $xfer += $output->writeFieldBegin('keywords', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::I64, TType::I32, scalar(keys %{$self->{keywords}}));
      {
        while( my ($kiter42,$viter43) = each %{$self->{keywords}}) 
        {
          $xfer += $output->writeI64($kiter42);
          $xfer += $output->writeI32($viter43);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{topics}) {
    $xfer += $output->writeFieldBegin('topics', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::I32, scalar(@{$self->{topics}}));
      {
        foreach my $iter44 (@{$self->{topics}}) 
        {
          $xfer += $output->writeI32($iter44);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{history}) {
    $xfer += $output->writeFieldBegin('history', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{history}}));
      {
        foreach my $iter45 (@{$self->{history}}) 
        {
          $xfer += $output->writeI64($iter45);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::UserHistoryItem;
use base qw(Class::Accessor);
Recomm::UserHistoryItem->mk_accessors( qw( story_id type timestamp ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{story_id} = undef;
  $self->{type} = 0;
  $self->{timestamp} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{story_id}) {
      $self->{story_id} = $vals->{story_id};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserHistoryItem';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{story_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserHistoryItem');
  if (defined $self->{story_id}) {
    $xfer += $output->writeFieldBegin('story_id', TType::STRING, 1);
    $xfer += $output->writeString($self->{story_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 2);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::UserHistory;
use base qw(Class::Accessor);
Recomm::UserHistory->mk_accessors( qw( history_items ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{history_items} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{history_items}) {
      $self->{history_items} = $vals->{history_items};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UserHistory';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size46 = 0;
          $self->{history_items} = [];
          my $_etype49 = 0;
          $xfer += $input->readListBegin(\$_etype49, \$_size46);
          for (my $_i50 = 0; $_i50 < $_size46; ++$_i50)
          {
            my $elem51 = undef;
            $elem51 = new Recomm::UserHistoryItem();
            $xfer += $elem51->read($input);
            push(@{$self->{history_items}},$elem51);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UserHistory');
  if (defined $self->{history_items}) {
    $xfer += $output->writeFieldBegin('history_items', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{history_items}}));
      {
        foreach my $iter52 (@{$self->{history_items}}) 
        {
          $xfer += ${iter52}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::IndexingAttachment;
use base qw(Class::Accessor);
Recomm::IndexingAttachment->mk_accessors( qw( global_docid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{global_docid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{global_docid}) {
      $self->{global_docid} = $vals->{global_docid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexingAttachment';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{global_docid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexingAttachment');
  if (defined $self->{global_docid}) {
    $xfer += $output->writeFieldBegin('global_docid', TType::I64, 1);
    $xfer += $output->writeI64($self->{global_docid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::RetrievalRequestInfo;
use base qw(Class::Accessor);
Recomm::RetrievalRequestInfo->mk_accessors( qw( keyword weight ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyword} = undef;
  $self->{weight} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyword}) {
      $self->{keyword} = $vals->{keyword};
    }
    if (defined $vals->{weight}) {
      $self->{weight} = $vals->{weight};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RetrievalRequestInfo';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{keyword});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{weight});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RetrievalRequestInfo');
  if (defined $self->{keyword}) {
    $xfer += $output->writeFieldBegin('keyword', TType::I64, 1);
    $xfer += $output->writeI64($self->{keyword});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{weight}) {
    $xfer += $output->writeFieldBegin('weight', TType::I32, 2);
    $xfer += $output->writeI32($self->{weight});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::RetrievalRequest;
use base qw(Class::Accessor);
Recomm::RetrievalRequest->mk_accessors( qw( keywords debug_level log_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keywords} = undef;
  $self->{debug_level} = 0;
  $self->{log_level} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keywords}) {
      $self->{keywords} = $vals->{keywords};
    }
    if (defined $vals->{debug_level}) {
      $self->{debug_level} = $vals->{debug_level};
    }
    if (defined $vals->{log_level}) {
      $self->{log_level} = $vals->{log_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RetrievalRequest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size53 = 0;
          $self->{keywords} = [];
          my $_etype56 = 0;
          $xfer += $input->readListBegin(\$_etype56, \$_size53);
          for (my $_i57 = 0; $_i57 < $_size53; ++$_i57)
          {
            my $elem58 = undef;
            $elem58 = new Recomm::RetrievalRequestInfo();
            $xfer += $elem58->read($input);
            push(@{$self->{keywords}},$elem58);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{debug_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{log_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RetrievalRequest');
  if (defined $self->{keywords}) {
    $xfer += $output->writeFieldBegin('keywords', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{keywords}}));
      {
        foreach my $iter59 (@{$self->{keywords}}) 
        {
          $xfer += ${iter59}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{debug_level}) {
    $xfer += $output->writeFieldBegin('debug_level', TType::I16, 2);
    $xfer += $output->writeI16($self->{debug_level});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{log_level}) {
    $xfer += $output->writeFieldBegin('log_level', TType::I16, 3);
    $xfer += $output->writeI16($self->{log_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::RetrievalResult;
use base qw(Class::Accessor);
Recomm::RetrievalResult->mk_accessors( qw( story_id score ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{story_id} = undef;
  $self->{score} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{story_id}) {
      $self->{story_id} = $vals->{story_id};
    }
    if (defined $vals->{score}) {
      $self->{score} = $vals->{score};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RetrievalResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{story_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{score});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RetrievalResult');
  if (defined $self->{story_id}) {
    $xfer += $output->writeFieldBegin('story_id', TType::I64, 1);
    $xfer += $output->writeI64($self->{story_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{score}) {
    $xfer += $output->writeFieldBegin('score', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{score});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Recomm::RetrievalResponse;
use base qw(Class::Accessor);
Recomm::RetrievalResponse->mk_accessors( qw( resp_code num_results results ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{resp_code} = 0;
  $self->{num_results} = 0;
  $self->{results} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{resp_code}) {
      $self->{resp_code} = $vals->{resp_code};
    }
    if (defined $vals->{num_results}) {
      $self->{num_results} = $vals->{num_results};
    }
    if (defined $vals->{results}) {
      $self->{results} = $vals->{results};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RetrievalResponse';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{resp_code});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{num_results});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size60 = 0;
          $self->{results} = [];
          my $_etype63 = 0;
          $xfer += $input->readListBegin(\$_etype63, \$_size60);
          for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
          {
            my $elem65 = undef;
            $elem65 = new Recomm::RetrievalResult();
            $xfer += $elem65->read($input);
            push(@{$self->{results}},$elem65);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RetrievalResponse');
  if (defined $self->{resp_code}) {
    $xfer += $output->writeFieldBegin('resp_code', TType::I32, 1);
    $xfer += $output->writeI32($self->{resp_code});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{num_results}) {
    $xfer += $output->writeFieldBegin('num_results', TType::I32, 2);
    $xfer += $output->writeI32($self->{num_results});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{results}) {
    $xfer += $output->writeFieldBegin('results', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{results}}));
      {
        foreach my $iter66 (@{$self->{results}}) 
        {
          $xfer += ${iter66}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
